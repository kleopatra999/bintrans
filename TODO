Instruction Scheduler

The code generated by the current translator is very sequential in
nature and is therefore bound to be slow especially on in-order
processors.  Implement a fast instruction scheduler.  The constraints
for scheduling can be inferred from the target machine description.

Skills: C, some assembler language

==========================

Address Space Problem

Our dynamic binary translator works as a user-level program without
special assistance by the operating system.  It must run the emulated
program within its own address space.  This is not a problem if the
address space of the binary translator is much larger than that of the
emulated program, i.e. when running i386 executables on the Alpha (a
64-bit architecture).  However, it results in collisions when both
address spaces have the same size.  The Dynamo dynamic optimizer faces
the same problem and solves it by mapping the translator to a memory
region which is rarely claimed by an emulated program.  Implement this
for bintrans.

Skills: C, UNIX/Linux system programming

==========================

Various Hand-Coded Translators

The primary goal of bintrans is to prove that good machine-adaptable
binary translation is possible by developing and implementing methods
to do that.  Of course, in order to claim that a particular code
generator is good, it is necessary to have points for comparison.  One
such point is the execution of native code on the target machine.
Another obvious comparison is to of a machine-generated translator via
a hand-coded translator.  We currently have a hand-coded translator
for PowerPC to Alpha code, but it would be nice to have more,
especially with i386 as source or target architecture.

Skills: C, some assembler language

==========================

Machine Descriptions

Machine-adaptable binary translation requires that machines be
described in some way.  Bintrans has its own machine description
language, capturing the syntax and semantics of instruction set
architectures.  We currently have descriptions of large subsets of the
PowerPC, Alpha and i386 architectures, but we obviously want more,
e.g. MIPS, SPARC, HP/PA.  Write and debug such a machine description
by running programs using an interpreter and debugger built
automatically from the machine description.

Skills: maybe Lisp, some assembly language

==========================

System Call Interfaces

The system call interfaces differ between different instruction set
architectures, even for the same operating system (e.g. Linux).  It is
therefore necessary to emulate the system call interface of a foreign
machine/operating system combination.  We currently emulate a small
subset of the system call interfaces for Linux/PowerPC and Linux/i386.
Complete those interfaces or write system call interface for other
machine/operating system combinations.  This work consists mainly of
converting data structures and finding or writing test programs.

Skills: C, UNIX/Linux system programming

Advanced: Develop a language for describing system call interfaces and
write a program which automatically generates code which implements an
interface from such a description.

Skills: C, UNIX/Linux system programming, interpreter/compiler design

==========================

Signal Handling

Bintrans does not yet deliver signals to the emulated program.  The
most important issue to take care of is the fact that translated code
cannot be interrupted at arbitrary points, but only between
translation blocks.  A way has to be found to interrupt the emulated
program between blocks without slowing down uninterrupted execution
speed.  Implement such a technique and write code to invoke a signal
handler within the emulated program.

Skills: C, UNIX/Linux system programming, some assembler language

==========================

High-Speed Interpreter

We can currently automatically generate interpreters from machine
descriptions.  The speed of these interpreters, however, is not
satisfactory.  This is mostly due to the fact that the technique for
generating C from the descriptions is very naive.  Another reason is
that some operations commonly found in machine languages cannot be
directly expressed in C, like sign extension, arithmetic right shifts
or rotations.  It should be investigated how fast a machine language
interpreter can be made, possibly by writing and optimizing one in
some machine language.  Techniques should be developed for
automatically generating fast interpreters from machine descriptions.

Skills: Lisp, C, some assembler language, interpreter/compiler design

==========================

Thread-Safety

Bintrans does not yet execute programs with multiple threads.  The
main issue is to either make the translator thread-safe or to make
sure that the translator is only run in at most one thread at once.

Skills: C, UNIX/Linux system programming

==========================

SIMD Extensions: AltiVec, MMX, 3DNOW!, SSE2, ...

Many current instruction set architectures provide SIMD (single
instruction - multiple data) extensions.  Bintrans currently provides
no way of describing such instructions, nor of translating them.
Develop a language for describing such instructions.  Write
descriptions for at least two such instructions set extensions.
Devise techniques for translating such instructions to efficient code
for traditional instruction sets and for translating from one such
extension to another.

Skills: Lisp, C, some assembler language, interpreter/compiler design
